<details>
<summary>DeadLock(교착상태)란 무엇인가요 ?</summary>
<div markdown="1">


- 한정된 자원을 여러 프로세스가 사용하려할때, 프로세스가 자원을 할당받지 못해서 다음 처리를 하지 못한채 대기하는 상태입니다. 
- 2개 이상의 프로세스가 서로 원하는 자원을 할당받고 있어 무한정 대기 상태에 빠져, 해당 프로세스들이 실행 상태로 변경 될 수 없는 상태입니다. 

</div>
</details>

<br/>

<details>
<summary>DeadLock의 발생 조건 4가지는 무엇인가요?</summary>
<div markdown="1">


- 상호 배제(Mutual exclusion)
  한 리소스는 한 번에 한 프로세스만이 사용할 수 있음
- 점유와 대기(Hold and wait)
  어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 가지고 있는 리소스를 기다리고 있음
- 비선점(No preemption)
  프로세스가 태스크를 마친 후 리소스를 자발적으로 반환할 때까지 기다림 (강제로 빼앗지 않는다)
- 환형 대기(Circular wait)
  Hold and wait 관계의 프로세스들이 서로를 기다림

</div>
</details>

<br/>

<details>
<summary>DeadLock을 해결하는 방법은 무엇이 있나요?</summary>
<div markdown="1">


- 방지(Prevention)
  할당 구조 측면에서, 교착상태가 발생할 수 있는 요구조건을 만족시키지 않게 함으로써 교착상태를 방지한다.
- 회피(Avoidance)
  리소스 할당의 측면에서, 교착상태가 발생할 가능성이 있는 자원 할당(unsafe allocation)을 하지 않는다.
  대표적으로 은행원 알고리즘, 자원 할당 그래프가 있다.
- 탐지 및 회복(Detection and Recovery)
  교착상태가 발생 할 수 있도록 놔 두고 교착상태가 발생 할 경우 찾아내어 고친다.
- 무시 
  데드락을 허용하지만, 해결의 비용이 커서 운영체제가 어떠한 처리도 하지 않음. 
  현대 운영체제가 채택 중인 방식

</div>
</details>

<br/>

<details>
<summary>은행원 알고리즘 이란 무엇인가요 ?</summary>
<div markdown="1">

- 교착 상태를 회피하는 방법 중 하나이다. 
- 프로세스가 자원을 요구할 때, 자원을 할당한 후에도 안정 상태로 남아있게 되는지 미리 검사하는 알고리즘이다. 
  - 안정 상태인 경우만 자원을 할당하고 그렇지 않은 경우 다른 프로세스들의 자원 해지시 까지 대기한다. 
- 안정 상태
  - 시스템이 교착상태를 일으키지 않으면서, 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태. 안전순서열이 존재해야한다. 
- 불안정 상태 
  - 안전순서열이 존재하지 않는 상태. 
  - 교착상태이기 위한 필요조건. (불안전 상태라고 항상 교착상태가 되는 것은 아님)
  - 즉 교착상태가 될 수 있는 상태.
- 안전순서열
  - 자원을 안전하게 주고 받을 수 있는 프로세스의 순서 
- 은행원 알고리즘 변수
    ```
  - 전체 자원: 시스템 내의 전체 자원 수
  - 가용 자원: 현재 사용가능한 자원의 수 
      -> 가용자원 = 전체 자원 - 모든 프로세스에게 할당한 자원
  - 최대 자원: 각 프로세스가 사용할 최대 자원
  - 할당 자원: 각 프로세스에게 할당된 자원
  - 기대 자원: 각 프로세스가 앞으로 사용할 자원의 수 
      -> 최대 자원 - 할당 자원
   ```
</div>
</details>
<br/>
<details>
<summary> 교착상태 회피(은행원 알고리즘)의 문제점</summary>
<div markdown="1">

1. 프로세스가 자신이 사용할 자원을 모두 미리 선언해야 하는데 이는 쉬운일이 아니다. 
  - 또한, 미리 선언한 자원이 정확하지 않으면 교착상태가 발생할 수 있다.
2. 시스템의 전체 자원의 수가 고정적이어야 한다.
  - 안정 상태인지 확인하기 위해서는 전체 자원의 수가 고정적이어야 하지만, 실제 컴퓨터에서는 고장이나 새로운 자원이 추가될 수 있으므로 자원의 수가 고정적이지 않다.
3. 자원이 낭비된다.
  - 은행원 알고리즘에서 모든 불안정 상태가 교착상태가 되는 것은 아니다. 즉, 교착상태 회피는 실제 교착상태가 발생하지 않는데도 발생할 것이라고 예상하기 때문에 자원을 효율적으로 사용하지 못하게 한다.
    - 불안정 상태가 교착상태의 필요조건이긴 하지만, 모든 불안정 상태 항상 교착상태로 이어지는 것은 아니다. 하지만 은행원 알고리즘은 모든 불안정 상태에선 자원을 할당하지 않기 때문에, 교착상태가 발생하지 않는 불안정 상태에 자원을 할당하지 않는 것은 사용할 수 있는 자원을 사용안하는 것이므로, 자원의 낭비이다.
    - 사용할 수 있는 자원임에도 데드락이 발생할지도 모른다는 우려 때문에 사용하지 않는다. 따라서 자원을 비효율적으로 사용하게 된다.
 
</div>
</details>

<br/>

<details>
<summary>자원 할당 그래프 설명</summary>
<div markdown="1">

- 프로세스가 어떤 자원을 할당받고 있고, 어떤 자원을 요청하며 대기하고 있는지를 방향 그래프로 표현한 것 
- 데드락 발생 여부를 탐지 할 수 있는 그래프
- 장점: 프로세스의 작업 방식을 제한하지 않으면서 교착상태를 파악할 수 있다.
- 단점: 자원 할당 그래프를 유지하는 작업으로 인해 오버헤드가 발생한다.
  - 오브헤드를 줄이기 위해서 자원이 할당될 때마다 사이클이 발생했는지 검사하는 것이 아니라, 일정 시간마다 검사하는 방법도 존재한다.
- 그래프의 요소
```
  - 프로세스 : 동그라미, P#
  - 자원 : 사각형, R#
  - 자원 사각형 안의 점 : 각 자원 타입이 할당 가능한 자원 인스턴스 갯수
    - 다중 자원 : 점이 여러개 
  - 화살표
    - P -> R 
      - 요청 화살표
      - P#이 R#을 요청 중인 상태를 의미한다. 
      - 프로세스가 요청만하고 자원을 할당받지 못한 상태로, 프로세스는 대기상태에 있음을 의미한다. 
    - R -> P 
      - 할당 화살표 
      - R#이 P#에게 할당 된 상태를 의미한다. 
```
- 자원 할당 그래프에서 사이클이 발생하면 교착상태가 발생한 것에 해당한다.
  - 하지만, 다중 자원을 사용하는 경우에는 자원 할당 그래프에 사이클이 있어도 교착상태가 아닐 수 있다.
  - 다중 자원 : 여러 프로세스가 동시에 사용할 수 있는 자원 (R#에 점이 여러개)
  - 사이클 : 그래프 상의 노드간 사이클을 의미한다. 환형대기와 같지않다. 
    - 사이클이 발생하여도, 다중 자원이어서 정상적으로 할당이 되어 점유 대기가 발생하지 않으면 환형대기가 발생하지 않기 때문이다.

</div>
</details>
<br/>

<details>
<summary>자원 할당 그래프 예시</summary>
<div markdown="1">
아래는 자원 할당 그래프의 예시이다. 
각 프로세스의 상태와, 데드락인지 아닌지 판별할 수 있어야한다. 

Q1.
![자원 할당 그래프](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdWO5az%2Fbtq5vD6FQRF%2F3k33gg5PnBZjDsZcnTcPAK%2Fimg.png)
<details>
<summary>Q1. 설명</summary>
<div markdown="1">

- P1은 R2의 자원을 점유하고 R1의 자원을 대기 중이다 - 점유 대기(Hold and wait)
- P2는 R1과 R2의 자원을 점유하고 R3의 자원을 대기 중이다 - 점유 대기(Hold and wait)
- P3은 R3의 자원을 가지고 있지만 아무런 추가 자원을 요청하지 않는다.

- P1과 P2는 점유 대기 상태에 있지만 P3가 아무런 자원을 요청하지 않고 있으므로 **환형 대기(Circular wait)** 상태가 아니다. 그래서 위 상황은 데드락 상태가 아니다.
</div>
</details>
<br/>

Q2. 
![데드락 상태에 빠진 자원 할당 그래프](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FI1RvP%2Fbtq5xu2Qigr%2FIk09zstjlr6jcialT145C0%2Fimg.png)


<details>
<summary>Q2. 설명</summary>
<div markdown="1">

- P3은 R2의 자원을 요청했으나 R2는 이미 할당 할 수 있는 자원을 모두 사용 했으므로, P3은 대기 상태에 빠지게 된다. 
- 여기서 R2는 P2에게 할당 되었고, P2는 R3을 기다리고 있다. 
- 하지만 R3은 이미 P3에게 할당 되어 있어 순환 대기 상태에 빠지게 되었다.
- P3 -> R2 -> P2 -> R3 -> P3
- P3 -> R2 -> P1 -> R1 -> P2 -> R3 -> P3

</div>
</details>
<br/>

Q3. 
![사이클이 발생했지만 데드락은 아닌 자원 할당 그래프](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlcXTJ%2Fbtq5wvOLkj3%2F7DOrbkQgDZ4sVvxLCeXSDk%2Fimg.png)

<details>
<summary>Q3. 설명</summary>
<div markdown="1">


- P1 -> R1 -> P2 -> R2 -> P1으로 사이클이 발생했다. 
- 하지만 R1타입의 자원은 인스턴스가 두개고 하나는 점유 대기 상태에 빠져 있는 P2에게 점유되어 있지만, 다른 하나는 P3에게 점유되어 있다. 
- P3에서 작업이 완료 되고 자원을 해제하면 P1에게 할당 될 수 있다. 
- R2 타입의 자원 역시 마찬가지로 P4에서 작업이 완료 되고 자원을 해제하면 P2에게 할당 될 수 있으므로 데드락 상태가 아니다.

</div>
</details>

</div>
</details>
<br/>

<details>
<summary>교착상태 회복 방법</summary>
<div markdown="1">

1. 교착 상태를 일으킨 모든 프로세스를 **강제 종료**
    - 종료된 프로세스들이 동시에 작업을 시작하면 다시 교착상태를 일으킬 수 있다.
    - 따라서 종료된 프로세스를 실행할 때는 순차적으로 실행해야 한다. 
    
  2. 교착 상태를 일으킨 프로세스 중 하나를 **강제 종료**
    - 어떤 프로세스를 종료할지 기준이 필요하다.
    - 기준 예시
      1. 우선순위가 낮은 프로세스를 먼저 종료
      2. 우선순위가 같은 경우, 작업 시간이 짧은 프로세스를 먼저 종료
      3. 위 조건이 같은 경우, 자원을 많이 사용하는 프로세스 먼저 종료

  3. 교착 상태의 프로세스의 자원 선점 
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시키면서, **선점대기** 조건 해제) 
    - 우선 순위가 낮은 프로세스나 현재까지의 실행시간이 적은 프로세스 위주로 프로세스 자원 선점
      - 수행 횟수 적은 프로세스 : 퀀

- **교착상태 회복에서 프로세스를 강제 종료하는 경우**엔, 강제 종료된 프로세스를 실행하기 전에 복구하는 작업도 해야 한다. 
  - 복구 작업: 프로세스가 강제 종료될 때에 체크 포인트를 만들어두고, 거기로 돌아간다.
- 이 작업은 작업량이 상당하여 프로세스에 부하를 주므로 체크포인트를 무분별하게 사용하지 말고 선택적으로 사용해야 한다.


</div>
</details>

<br/>

<details>
<summary>기아 상태란 무엇인가요 ?</summary>
<div markdown="1">

- 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태이다. 
- 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상태이다. 

</div>
</details>

<br/>

<details>
<summary>교착 상태와 기아 상태를 비교해보세요</summary>
<div markdown="1">

- 교착상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말하고 기아 상태는 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태이다. 즉 **교착 상태는 여러 프로세스가 동일한 자원 점유를 원할 때 발생**하고 **기아 상태는 여러 프로세스가 자원을 점유하기 위해 경쟁 할 때** 특정 프로세스는 영원히 자원 할당을 받지 못하는 것이다. 
- 교착상태와의 차이점: 
  - 기아 상태: **운영체제의 잘못된 정책으로** 인해 특정 프로세스의 작업이 지연되는 것 (인재같은 것)
  - 교착 상태: 여러 프로세스가 작업을 진행하다 보니 **자연적으로** 일어나는 문제 (자연재해같은 것)
</div>
</details>

<br/>


<details>
<summary>식사하는 철학자 문제에 대해서 설명해보세요</summary>
<div markdown="1">

<img height= 400 src="http://upload.wikimedia.org/wikipedia/commons/7/7b/An_illustration_of_the_dining_philosophers_problem.png">

- **원탁**에 둘러 앉은 철학자들이 아래와 같은 과정을 통해 식사를 한다. 
    ```
    1. 일정 시간 생각을 한다.
    2. 자신의 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
    3. 자신의  오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
    4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
    5. 오른쪽 포크를 내려놓는다.
    6. 왼쪽 포크를 내려놓는다.
    7. 다시 1번으로 돌아간다.
    ```
- 만약 모든 철학자들이 동시에 자신의 왼쪽 포크를 잡는다면(2번과정), 모든 철학자들이 자기 오른쪽의 포크가 사용 가능해질 때까지 기다려야 한다. (데드락 발생)
- 이 상태에서는 모든 철학자가 영원히 3번 상태에 머물러있어 아무것도 진행할 개수가 없게 되는데, 이것이 교착(Deadlock)상태이다.
- 식사하는 철학자 문제에서 교착 상태가 발생하는 이유
    ```
    - 상호배타(Mutual Exclusion)
        예) 젓가락은 한번에 한 철학자만 사용할 수 있다.
        하나의 포크는 한 철학자가 사용하면 다른 철학자가 사용할 수 없다. 
    - 보유 및 대기(Hold and Wait) 
        예) 집어든 젓가락은 계속 들은 채로 사용중인 반대쪽 젓가락을 기다린다.
        철학자는 대기할 때, 왼쪽 포크를 가진 채로 오른쪽 포크를 기다린다.
    - 비선점(No Preemption) 
        예) 이미 누군가 집어든 젓가락을 강제로 뺏을 수 없다.
        포크를 사용하고 있는 철학자가 포크를 내려놓아야만 다른 철학자가 포크를 사용할 수 있다
    - 환형대기(Circular Wait)
        예) 모든 철학자들이 자신의 오른쪽에 앉은 철학자가 젓가락을 놓기를 기다린다.
        포크를 가진 철학자와 포크를 대기하는 철학자들의 관계가 원을 이룬다. 따라서 서로가 서로의 진행을 막는 상태가 된다.
    ``` 
  - 상호배제와 비선점은 임계구역을 보호하면 발생한다.
  - 점유대기와 원형대기는 프로세스들의 관계이다. 

</div>
</details>
