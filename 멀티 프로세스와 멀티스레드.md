# 1️⃣ 프로세스와 스레드

<details>
<summary>스레드의 문맥교환이 프로세스의 문맥교환보다 빠른 이유는 무엇인가요 ?</summary>
<div markdown="1">
스레드의 문맥교환은 캐시를 비우지 않기 때문에 빠르다.
</div>
</details>

<details>
<summary>문맥교환시 오버헤드가 발생하는 이유 ?</summary>
<div markdown="1">
프로세스는 독립된 주소 공간을 사용하므로, 문맥교환시 캐시 메모리 초기화와 같은 무거운 작업이 진행되어 오버헤드 발생한다.
</div>
</details>

<details>
<summary>문맥교환이란 ?</summary>
<div markdown="1">
1. CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
2. CPU가 다음 프로세스로 넘어갈 때, 
    1. 운영체제는 CPU를 내어주는 프로세스의 상태를 해당 프로세스의 PCB에 저장하고,
    2. CPU를 얻는 프로세스의 상태를 PCB에서 읽어서 복원
3. 언제 발생?
    1. timer interrupt 발생
        
        timer interrupt는 현재 실행중인 프로세스의 CPU 할당시간이 끝났을 때 발생한다.
        이때 운영체제가 CPU를 다른 프로세스에게 넘긴다.
        
    2. IO요청 System Call이 발생
        
        System Call을 요청안 프로세스가 CPU를 받아도 처리할 작업이 없는 경우,
        다른 프로세스로 CPU가 넘어가게 된다.
</div>
</details>

<details>
<summary>멀티 스레딩의 장점은 무엇이고, 이유는 무엇인가요 ?</summary>
<div markdown="1">
  - 응답성 향상
      - 한 스레드가 입출력 작업 중이라도, 다른 스레드가 사용자의 요청에 응답할 수 있다.
  - 자원 공유로 인한 자원 소모량 감소
      - 한 프로세스의 자원을 모든 스레드가 공유하게 되어,
      - 스레드간의 통신은 프로세스의 것보다 간단하다.
      - 전역변수 or heap
      - 메모리 공간과 시스템 자원 소모 절약
</div>
</details>

<details>
<summary>스레드간의 통신은 어떻게 이뤄지나요</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>프로세스간의 통신은 어떻게 이뤄지나요</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>멀티 스레딩의 단점을 설명해보세요</summary>
<div markdown="1">
- 스레드간 공유하는 프로세스 자원이 있기 때문에, 자원을 절약할수있지만, 같은 자원을 여러 스레드가 동시에 접근할 수 있기 때문에 발생하는 문제가 있다. 다른 스레드가 사용중인 변수를 읽거나 수정하게 되면 작업에 영향을 줄 수 있다.
- 하나의 스레드에 문제가 발생하면, 전체 스레드에 영향을 줄 수 있다. (자원을 공유하고 있기 때문에)
</div>
</details>

<details>
<summary>멀티 스레딩의 단점을 보완하기 위한 방법을 설명해보세요</summary>
<div markdown="1">
- 동기화 작업을 한다. 동기화 작업으로 처리 순서를 제공하면서 공유 자원에 대한 접근을 제어한다.
    - 해당 방법의 단점은 없나요 ?
        - 과도한 접근제어는 병목현상을 일으킬 수 있다.
</div>
</details>

<details>
<summary>멀티 프로세스와 멀티 스레드의 장단점을 설명해보세요 </summary>
<div markdown="1">

</div>
</details>

<details>
<summary>어떤 시스템에 멀티 프로세스 방식이 적합할까요 ?</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>어떤 시스템에 멀티 스레드 방식이 적합할까요 ?</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>프로세스의 동적 영역과 정적 영역에 대해 설명해보세요</summary>
<div markdown="1">
- 정적 영역
    - 정적 영역은 프로세스가 실행되는 동안 바뀌지 않는 영역
    - 코드, 전역 데이터, 파일
- 동적 영역
    - 정적 영역은 프로세스가 실행되는 동안 값이 바뀌거나, 새로 생성 삭제 되는 영역
    - 레지스터 값, 스택, 힙
</div>
</details>

<details>
<summary>멀티스레드가 효율성을 향상시킬 수 있는 이유는 무엇인가요 ?</summary>
<div markdown="1">
각 스레드는 프로세스의 정적 영역의 자원을 공유함으로써 자원의 낭비를 막고 효율성을 향상한다. 
</div>
</details>

<details>
<summary>프로세스의 동적영역이 각 스레드마다 할당되는 이유는 무엇인가요 ?</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>동기란 무엇인가요 ?</summary>
<div markdown="1">
- 메소드를 실행시킴과 `동시에` 반환 값이 기대되는 경우
- 메소드 실행과 반환 값이 끈임 없이 한 번에 이어지는 경우
- 실행되었을 때 값이 반환되기 전까지는 `blocking` 되어 있다는 것을 의미한다
</div>
</details>

<details>
<summary>비동기란 무엇인가요 ?</summary>
<div markdown="1">
- 동기가 아닌 방식
- `blocking`되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task 를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.
</div>
</details>

<details>
<summary>임계구역이란 무엇인가요 ?</summary>
<div markdown="1">
동일 자원을 동시에 접근하는 작업을 실행시키는 코드 영역
</div>
</details>

<details>
<summary>임계구역 해결을 위한 기본 조건은 무엇이 있나요 ?</summary>
<div markdown="1">
- 상호배제 : Mutual Exclusion → ****Mutex****
    - 어떤 프로세스가 임계구역에 들어와있다면, 다른 프로세스는 임계구역에 들어갈 수 없습니다.
- 한정대기 : Bounded Waiting
    - 한 프로세스가 임계구역에 무한정있어, 다른 프로세스가 임계구역에 들어가지 못하면 안됩니다.
- 진행 : Progress
</div>
</details>

<details>
<summary>임계구역의 해결책엔 무엇이 있나요 ?</summary>
<div markdown="1">
- 뮤텍스 (****Mutex lock :**** Mutual Exclusion)
- 세마포어
    - 카운팅 세마포어
    - 이진 세마포어
- 모니터
</div>
</details>


<details>
<summary> 🚧 멀티 프로세스가 그런 단점이 있다면 왜 사용하는가? 전부 멀티 스레드로 구현하는 것이 시스템에 이로운 것이 아닌가? </summary>
<div markdown="1">

한 프로세스에서 시스템 콜이 발생했을 때, IO 작업이 진행되는 동안 더이상 CPU를 가지고 다른 작업을 수행할 일이 없는 경우에 다른 프로세스가 CPU를 사용할 수 있도록 하는 것이 효율적이다.
CPU가 놀지 않도록 만들고, 사용자에게 빠르게 일처리를 제공해주기 위한 것이다.

</div>
</details>

<br/>

<details>
<summary> 🚧 인터럽트가 무엇인가? </summary>
<div markdown="1">

- 프로그램 실행하는 중 system call, IO 작업과 같은 이벤트 발생
→ 현재 실행중인 작업 중단
→ 발생한 이벤트 처리
→ 실행중이던 작업으로 복귀하는 것

- 넓은 의미의 Interrupt
    1. Interrupt (하드웨어 인터럽트)
        - 하드웨어가 발생시킨 인터럽트
        - ex) 타이머 인터럽트, IO 컨트롤러 인터럽트
    2. Trap (소프트웨어 인터럽트)
        - =사용자 프로그램이 발생시킨 인터럽트
        - 발생하는 경우
        1. Exception = 프로그램이 오류 일으킨 경우
        (0으로 나누는 경우, 명령어를 잘못 사용한 경우, 오버플로우)
        1. System Call = 프로그램이 운영체제에게 서비스 요청to 커널 함수를 호출하는 경우
        (소프트웨어 실행 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.)

</div>
</details>

<br/>

<details>
<summary> 🚧 인터럽트 처리 과정 </summary>
<div markdown="1">

1. 인터럽트 발생
2. 현재 레지스터 셋, program counter 저장 후 cpu 제어권 인터럽트 처리 루틴에 넘어감
- 저장하는 이유: 인터럽트 처리 후에 진행하던 작업을 재개하기 위해서

</div>
</details>

<br/>

<details>
<summary> 🚧 Linux의 대표적인 system call </summary>
<div markdown="1">

## Linux의 대표적인 시스템 콜

fork(), exec(), wait(): 프로세스 생성 및 제어와 관련된 시스템 콜

fork(), exe(): 프로세스 생성 관련

wait(): 해당 프로세스가 생성한 자식 프로세스가 끝날 때까지 기다리는 명령어

### **Fork**

> 새로운 Process를 생성할 때 사용
> 

현재 프로세스를 그대로 복사하여 생성

자식 프로세스와의 실행을 이후에 구분하는 방법: fork() 반환 값

부모 프로세스 fork 반환값: 자식 프로세스의 PID

child 프로세스의 fork 반환 값: 0

실패시 : 음수 

## exec

자식 프로세스를 부모 프로세스와 다른 프로그램으로 만들고 싶을 때 사용

프로세스의 주소공간 중 code 영역에 새로운 프로그램의 코드를 가져와서 덮어씌운다.

씌운 이후, 데이터 영억, 힙 영역, 다른 메모리 영역이 초기화 됨

새로운 코드가 실행된다. = exec() 이후의 코드 부분은 실행되지 않는다.


## Wait

자식 프로세스가 모두 종료될때까지 대기하도록 한다.

</div>
</details>


