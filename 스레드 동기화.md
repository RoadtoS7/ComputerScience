

<details>
<summary> 세마포어 란? </summary>
<div markdown="1">

- 임계 구역 문제를 해결하기 위한 방법 중 하나
- 언제 사용? 여러 개의 공유 자원을 획득하고, 반납하는 연산을 할 때
- 구성요소: 세마포어, P연산, V연산
  - 세마포어: 사용 가능한 자원의 개수를 나타낸다.
  - P연산: 사용 가능한 자원이 있으면(세마포어 값이 0보다 크면) 자원을 1개 감소시키고, 임계구역으로 진입한다.   
  만일 사용 가능한 자원이 없다면, 대기한다.
  - V연산: 자원을 반납한다.(세마포어 값을 1 증가시킨다.) 만일 임계 구역을 진입하기 위해 대기 중인 프로세스를 깨운다.
- 세마포어를 사용하기 위해서는 시스템에서 test-and-set이 분리되지 않고 한번에 실행되어야 한다.
- 단점: 프로그래머가 실수하여 임계 구역이 보호되지 않을 수 있다.

</div>
</details>

<br/>

<details>
<summary> 뮤텍스 란? </summary>
<div markdown="1">
- 이진 세마포어이다.
- 언제 사용? 임계 구역에 락을 걸고, 풀어서 여러 프로세스/스레드를 상호배제할 때 사용한다.
</div>
</details>

<br/>

<details>
<summary> 뮤텍스와 세마포어의 차이점? 언제 사용? </summary>
<div markdown="1">
- 세마포어: 임개구역에 세마포어 값으로 지정된 개수만큼 프로세스/스레드가 진입할 수 있다.
- 뮤텍스: 임계 구역에 오직 하나의 프로세스/스레드만 진입할 수 있다.

<br/>

- 세마포어: 세마포어는 뮤텍스와 달리 해제(Unlock)의 주체가 획득(Lock)과 같지 않아도 된다. 어떤 프로세스가 세마포어의 값을 감소시켜도 다른 프로세스가 풀어줄 수 있다.

- 출처:  https://velog.io/@codemcd/운영체제OS-9.-프로세스-동기화-2
- 출처: https://velog.io/@logandev/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4-%EC%B0%A8%EC%9D%B4


</div>
</details>

<br/>

<details>
<summary> 모니터 란? </summary>
<div markdown="1">

- 보호할 자원을 임계구역으로 숨기고 임계 구역에서 작업할 수 있는 인터페이스만 제공하여 자원을 보호한다.
- 순서
  - 공용 자원에 접근하려는 프로세스는 직접 P연산/V연산을 사용하지 않고, 모니터에 작업을 요청한다.
  - 모니터는 요청받은 작업을 모니터 큐에 저장한 후, 순서대로 처리하고 그 결과를 프로세스에 알려준다. 
- 모니터에는 한번에 하나의 프로세스/스레드만 접근할 수 있다.

</div>
</details>

<br/>

<details>
<summary> 🚧뮤텍스 <-> 모니터 차이점 </summary>
</details>

<br/>

<summary>프로세스 간 통신은 왜 필요한가요 ?</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>프로세스 간 통신의 방식엔 어떤 것들이 있나요 ?</summary>
<div markdown="1">

</div>
</details>


<details>
<summary>생산자-소비자 문제에 대해서 설명해보세요 </summary>
<div markdown="1">

</div>
</details>

<details>
<summary>임계구역 해결 방법엔 어떤 것들이 있나요 ? </summary>
<div markdown="1">

</div>
</details>
<details>
<summary>피터슨 알고리즘에 대해서 설명해보세요 </summary>
<div markdown="1">

</div>
</details>

<details>
<summary>데커 알고리즘에 대해서 설명해보세요 </summary>
<div markdown="1">

</div>
</details>

<details>
<summary>데드락이란 무엇인가요 ?</summary>
<div markdown="1">

</div>
</details>

<details>
<summary>데드락을 해결하는 방법은 무엇이 있나요?</summary>
<div markdown="1">

</div>
</details>

<br/>

<details>
<summary>경쟁상태란 무엇인가요 ?</summary>


</div>
</details>

<br/>

<details>
<summary> 바쁜 대기(busy waiting) 방식이 무엇인가? </summary>
<div markdown="1">

- 임계 구역에 진입하기 위해 프로세스/스레드가 대기할 때 while 문을 돌면서 대기하는 것

</div>
</details>

<br/>



<details>
<summary> 🚧 바쁜 대기(busy waiting) 과 block-and-wakeup 방식의 차이점이 무엇인가? </summary>
<div markdown="1">



</div>
</details>

<br/>


<details>
<summary> 🚧 바쁜 (busy waiting) 과 block-and-wakeup 방식은 언제 사용하는가?  
 </summary>
<div markdown="1">

</div>
</details>

<br/>

<details>
<summary> 🚧 세마포어를 잘못 사용할 때 발생할 수 있는 문제점
 </summary>
<div markdown="1">

</div>
</details>

<br/>


<details>
<summary>🚧뮤텍스, 세마포어, 모니터가 언어에서 어떻게 사용되나요 ?</summary>
<div markdown="1">

- Kotlin
- Swift

</div>
</details>

<details>
<summary>멀티 프로세스가 그런 단점이 있다면 왜 사용하는가? 전부 멀티 스레드로 구현하는 것이 시스템에 이로운 것이 아닌가? </summary>
<div markdown="1">

- 여러개의 프로세스를 쓰는게 CPU 자원을 효율적으로 사용할 수 있다. (CPU를 놀지 않게 한다.)
  - 한 프로세스에서 시스템 콜이 발생했을 때, IO 작업이 진행되는 동안 더이상 CPU를 가지고 다른 작업을 수행할 일이 없는 경우에 다른 프로세스가 CPU를 사용할 수 있도록 하는 것이 효율적이다.
CPU가 놀지 않도록 만들고, 사용자에게 빠르게 일처리를 제공해주기 위한 것이다.
- 안정성, 보안성 측면에서, 멀티 스레드 방식보다 더 우수하다.  

</div>
</details>

<details>
<summary>인터럽트가 무엇인가? </summary>
<div markdown="1">

- 프로그램 실행하는 중 system call, IO 작업과 같은 이벤트 발생 시
    → 현재 실행중인 작업 중단
    → 발생한 이벤트 처리
    → 실행중이던 작업으로 복귀하는 것

- 넓은 의미의 Interrupt
    1. Interrupt (하드웨어 인터럽트)
        - 하드웨어가 발생시킨 인터럽트
        - ex) 타이머 인터럽트, IO 컨트롤러 인터럽트
    2. Trap (소프트웨어 인터럽트)
        - = 사용자 프로그램이 발생시킨 인터럽트
        - 발생하는 경우
        1. Exception = 프로그램이 오류 일으킨 경우
        (0으로 나누는 경우, 명령어를 잘못 사용한 경우, 오버플로우)
        1. System Call = 프로그램이 운영체제에게 서비스 요청to 커널 함수를 호출하는 경우
        (소프트웨어 실행 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.)

</div>
</details>

<details>
<summary>인터럽트 처리 과정 </summary>
<div markdown="1">

1. 인터럽트 발생
2. 현재 CPU의 레지스터 셋, program counter를 PCB에 저장 후 cpu 제어권 인터럽트 처리 루틴에 넘어감
- 저장하는 이유: 인터럽트 처리 후에 진행하던 작업을 재개하기 위해서

</div>
</details>

<details>
<summary> 🚧 Linux의 대표적인 system call </summary>
<div markdown="1">

## Linux의 대표적인 시스템 콜

fork(), exec(), wait(): 프로세스 생성 및 제어와 관련된 시스템 콜

fork(), exe(): 프로세스 생성 관련

wait(): 해당 프로세스가 생성한 자식 프로세스가 끝날 때까지 기다리는 명령어

### **Fork**

> 새로운 Process를 생성할 때 사용
> 

현재 프로세스를 그대로 복사하여 생성

자식 프로세스와의 실행을 이후에 구분하는 방법: fork() 반환 값

부모 프로세스 fork 반환값: 자식 프로세스의 PID

child 프로세스의 fork 반환 값: 0

실패시 : 음수 

## exec

자식 프로세스를 부모 프로세스와 다른 프로그램으로 만들고 싶을 때 사용

프로세스의 주소공간 중 code 영역에 새로운 프로그램의 코드를 가져와서 덮어씌운다.

씌운 이후, 데이터 영억, 힙 영역, 다른 메모리 영역이 초기화 됨

새로운 코드가 실행된다. = exec() 이후의 코드 부분은 실행되지 않는다.


## Wait

자식 프로세스가 모두 종료될때까지 대기하도록 한다.

</div>
</details>
