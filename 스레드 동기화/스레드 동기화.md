<details>
<summary> 세마포어 란? </summary>
<div markdown="1">

- 임계 구역 문제를 해결하기 위한 방법 중 하나
- 언제 사용? 여러 개의 공유 자원을 획득하고, 반납하는 연산을 할 때
- 구성요소: 세마포어, P연산, V연산
  - 세마포어: 사용 가능한 자원의 개수를 나타낸다.
  - P연산: 사용 가능한 자원이 있으면(세마포어 값이 0보다 크면) 자원을 1개 감소시키고, 임계구역으로 진입한다.   
  만일 사용 가능한 자원이 없다면, 세마포어 큐에서 대기한다.
  - V연산: 자원을 반납한다.(세마포어 값을 1 증가시킨다.) 만일 임계 구역을 진입하기 위해 대기 중인 프로세스를 깨운다. 
  
    - 세마포어가 block-and-wakeup 방식으로 구현된 경우: 임계구역을 사용중인 프로세스가 작업을 마치면 다음 프로세스에게, 임계구역을 사용하라는 동기화 신호를 보낸다. 

  ```
  Semaphore(n); // n은 공유 가능한 자원의 수
  P() // 잠금 : 임계구역이 사용중임을 표시 : 감소 연산 

  // critical section

  V() // 잠금 해제 : 임계구역이 비었음을 표시 : 증가 연산
  ```
- 세마포어를 사용하기 위해서는 시스템에서 test-and-set이 분리되지 않고 한번에 실행되어야 한다.
- 단점: 프로그래머가 실수하여 임계 구역이 보호되지 않을 수 있다.

</div>
</details>

<br/>

<details>
<summary> 뮤텍스 란? </summary>
<div markdown="1">

- 언제 사용? 임계 구역에 락을 걸고, 풀어서 여러 프로세스/스레드를 상호배제할 때 사용한다.
</div>
</details>

<br/>

<details>
<summary> 뮤텍스와 세마포어의 차이점? </summary>
<div markdown="1">

- 세마포어 <-> 뮤텍스 비교표
![세마포어 vs 뮤텍스](./%08%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4vs%EB%AE%A4%ED%85%8D%EC%8A%A4.jpg)




1. 세마포어는 신호(sinal) 체계를 갖는다.  
뮤텍스는 잠금(locking) 체계를 갖는다.
   - 세마포어 값은 wait(), signal()을 통해 수정된다.
   - 뮤텍스 객체는 locked, unlocked 상태가 존재한다.

  <br/>

1. 세마포어는 integer 변수이다.   
뮤텍스는 객체이다.


- 세마포어: 임개구역에 세마포어 최대 값으로 지정된 개수만큼 프로세스/스레드가 진입할 수 있다.
- 뮤텍스: 임계 구역에 오직 하나의 프로세스/스레드만 진입할 수 있다.

<br/>

- 세마포어: 세마포어는 뮤텍스와 달리 해제(Unlock)의 주체가 획득(Lock)과 같지 않아도 된다. 어떤 프로세스가 세마포어의 값을 감소시켜도 다른 프로세스가 풀어줄 수 있다.


<br/>

- 세마포어: 값이 운영체제, 커널에 저장된다.
  - 세마포어는 integer 변수이다. 숫자 놀이(증감 연산)를 통해 동기화한다.
  - 세마포어는 뮤텍스가 될 수 있다. (이진 세마포어)
  
- 뮤텍스: 
  - 프로세스가 값을 관리한다.
  - lock, unlock 상태를 갖는다. 
  - key를 이용하여 동기화 한다.
  - 뮤텍스는 세마포어가 될 수 없다.
    - 이유: 신호체계가 존재하지 않기 때문이다.


<br/>

- 세마포어 뮤텍스 차이점 표: https://www.guru99.com/mutex-vs-semaphore.html#4

- 상세 내용 출처: https://afteracademy.com/blog/difference-between-mutex-and-semaphore-in-operating-system
  
- 출처:  https://velog.io/@codemcd/운영체제OS-9.-프로세스-동기화-2
- 출처: https://velog.io/@logandev/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4-%EC%B0%A8%EC%9D%B4


</div>
</details>

<br/>

<details>
<summary> 모니터 란? </summary>
<div markdown="1">

- 모니터란 일종의 세마포어에 대한 캡슐화, 인터페이스, 시스템 콜 과 비슷한 개념이다.
  - 보호할 자원을 임계구역으로 숨기고 임계 구역에서 작업할 수 있는 인터페이스만 제공하여 자원을 보호한다.
- P()와 V() 연산을 잘못 사용할 수 있다는 세마포어의 단점을 보완한 방법이다.
- P()와 V() 연산을 프로세스가 직접하지 않게 하기 위해, 프로세스가 모니터에게 작업 요청 및 응답을 받아 임계구역 작업을 처리한다.

- 순서
  - 공용 자원에 접근하려는 프로세스는 직접 P연산/V연산을 사용하지 않고, 모니터에 작업을 요청한다.
  - 모니터는 요청받은 작업을 모니터 큐에 저장한 후, 순서대로 처리하고 그 결과를 프로세스에 알려준다.

- 모니터에는 한번에 하나의 프로세스/스레드만 접근할 수 있다.

</div>
</details>

<br/>

<details>
<summary> 🚧 세마포어 <-> 모니터 차이점  </summary>
<div markdown="1">

1. 세마포어의 wake-up(signal()) signal은 저장되지만, 모니터는 저장 되지 않는다.

2. 세마포어는 wait(), singal()의 호출 순서에 관계 없이 동일하게 동작한다. 모니터는 호출 순서에 따라 동작이 다르다.

출처: https://lass.cs.umass.edu/~shenoy/courses/fall16/lectures/Lec09.pdf

</div>

</details>

<br/>

<details>
<summary>멀티 프로세스가 그런 단점이 있다면 왜 사용하는가? 전부 멀티 스레드로 구현하는 것이 시스템에 이로운 것이 아닌가? </summary>
<div markdown="1">

- 여러개의 프로세스를 쓰는게 CPU 자원을 효율적으로 사용할 수 있다. (CPU를 놀지 않게 한다.)
  - 한 프로세스에서 시스템 콜이 발생했을 때, IO 작업이 진행되는 동안 더이상 CPU를 가지고 다른 작업을 수행할 일이 없는 경우에 다른 프로세스가 CPU를 사용할 수 있도록 하는 것이 효율적이다.
CPU가 놀지 않도록 만들고, 사용자에게 빠르게 일처리를 제공해주기 위한 것이다.
- 안정성, 보안성 측면에서, 멀티 스레드 방식보다 더 우수하다.  

</div>
</details>

<br/>

<details>
<summary>인터럽트가 무엇인가? </summary>
<div markdown="1">

- 프로그램 실행하는 중 system call, IO 작업과 같은 이벤트 발생 시
    → 현재 실행중인 작업 중단
    → 발생한 이벤트 처리
    → 실행중이던 작업으로 복귀하는 것

- 넓은 의미의 Interrupt
    1. Interrupt (하드웨어 인터럽트)
        - 하드웨어가 발생시킨 인터럽트
        - ex) 타이머 인터럽트, IO 컨트롤러 인터럽트
    2. Trap (소프트웨어 인터럽트)
        - = 사용자 프로그램이 발생시킨 인터럽트
        - 발생하는 경우
        1. Exception = 프로그램이 오류 일으킨 경우
        (0으로 나누는 경우, 명령어를 잘못 사용한 경우, 오버플로우)
        1. System Call = 프로그램이 운영체제에게 서비스 요청to 커널 함수를 호출하는 경우
        (소프트웨어 실행 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.)

</div>
</details>

<details>
<summary>인터럽트 처리 과정 </summary>
<div markdown="1">

1. 인터럽트 발생
2. 현재 CPU의 레지스터 셋, program counter를 PCB에 저장 후 cpu 제어권 인터럽트 처리 루틴에 넘어감
- 저장하는 이유: 인터럽트 처리 후에 진행하던 작업을 재개하기 위해서

</div>
</details>

<details>
<summary> 🚧 Linux의 대표적인 system call </summary>
<div markdown="1">

## Linux의 대표적인 시스템 콜

fork(), exec(), wait(): 프로세스 생성 및 제어와 관련된 시스템 콜

fork(), exe(): 프로세스 생성 관련

wait(): 해당 프로세스가 생성한 자식 프로세스가 끝날 때까지 기다리는 명령어

### **Fork**

> 새로운 Process를 생성할 때 사용
> 

현재 프로세스를 그대로 복사하여 생성

자식 프로세스와의 실행을 이후에 구분하는 방법: fork() 반환 값

부모 프로세스 fork 반환값: 자식 프로세스의 PID

child 프로세스의 fork 반환 값: 0

실패시 : 음수 

## exec

자식 프로세스를 부모 프로세스와 다른 프로그램으로 만들고 싶을 때 사용

프로세스의 주소공간 중 code 영역에 새로운 프로그램의 코드를 가져와서 덮어씌운다.

씌운 이후, 데이터 영억, 힙 영역, 다른 메모리 영역이 초기화 됨

새로운 코드가 실행된다. = exec() 이후의 코드 부분은 실행되지 않는다.


## Wait

자식 프로세스가 모두 종료될때까지 대기하도록 한다.

</div>
</details>

<br/>

<details>
<summary> 바쁜 대기(busy waiting) 방식이 무엇인가? </summary>
<div markdown="1">

- 임계 구역에 진입하기 위해 프로세스/스레드가 대기할 때 while 문을 돌면서 대기하는 것

</div>
</details>

<br/>

---

<details>
<summary> 🚧 모니터 큐 란?</summary>
</details>


<br/>

<details>
<summary> 🚧 세마포어 큐 란?</summary>
</details>

<br/>

<details>
<summary>프로세스 간 통신은 왜 필요한가요 ?</summary>
<div markdown="1">

프로세스는 데이터를 주고 받으며 협업하기 위해서 프로세스간 통신이 필요하다.

</dib>

</div>
</details>

<details>
<summary>프로세스 간 통신의 방식엔 어떤 것들이 있나요 ?</summary>
<div markdown="1">
   
   1. 전역 변수 
   2. 파일
   3. 익명 파이프
   4. Named 파이프
   5. 소켓 
   6. 원격 프로시저 호출

  1. 전역 변수 
     - 전송자가 전역변수에 데이터를 쓰면, 수신자가 전역변수에서 데이터를 읽어간다.
     - 운영체제의 지원 없이 사용 가능
     - 단방향 통신
     - 단방향 통신인 이유: 전역 변수 1개를 이용하여 두 프로세스가 동시에 데이터를 전송할 경우, 두 데이터 중 하나는 사라지기 때문이다.
     - 직접적으로 관련있는 프로세스간에 주로 사용  
     ex) 부모 프로세스와 자식 프로세스   
     부모 프로세스가 선언한 전역 변수를 이용해 자식 프로세스와 통신할 수 있다.
     - 운영체제가 동기화를 제공하지 않는다.   
     = 바쁜 대기를 돌면서, 전역변수에 값이 들어왔는지 매번 체크해야 한다.

  1. 파일
    - 전송자가 파일에 데이터를 쓰면, 수신자가 그 데이터를 읽어가는 방식으로 통신한다.
    - 운영체제의 지원없이 사용 가능
    - 단방향 통신
    - 운영체제가 동기화를 제공하지 않는다.  
    = 부모 프로세스가 wait()함수를 호출하여, 자식 프로세스의 작업이 끝날 때까지 대기하는 방식으로 동기화한다.
    

  2. 익명 파이프
    - 단방향 통신
    - 운영체제에서 동기화를 지원한다. -> 바쁜대기를 하지 않아도 된다. 
    = 수신자 프로세스가 파이프에 읽기 연산을 수행했을 때, 송신자 프로세스가 아직 파이프에 쓰기 연산을 하지 않았다면 수신자 프로세스는 대기 상태가된다. 이후, 송신자 프로세스가 파이프에 데이터를 쓰는 순가 대기상태에서 풀린다.
    - 부모 프로세스와 자식 프로세스와 같이 서로 관련있는 프로세스간에만 사용

  3. Named 파이프
    - 단방향 통신  
    - 서로 관련 없는 프로세스간 통신에도 사용된다.
    
    
  4. 소켓 
    - 양방향 통신
    - 운영체제에서 동기화를 지원한다. -> 바쁜대기를 하지 않아도 된다.

  5. 원격 프로시저 호출
    - 다른 컴퓨터에 존재하는 메서드를 호출하는 것
    - 일반적으로 소켓을 이용하여 구현한다.


</div>
</details>


<details>
<summary>생산자-소비자 문제에 대해서 설명해보세요 </summary>
<div markdown="1">
- 생산자 프로세스는 공유 버퍼에 물건을 생산에서 넣는 역할을 한다.
- 소비자 프로세스는 공유 버퍼에서 물건을 꺼내서 소비하는 역할을 한다.
- 버퍼가 비었는지/가득찼는지 여부를 확인하기 위해, 자원의 총량을 갖는 sum 변수를 사용한다.
- 생산자 프로세스와 소비자 프로세스가 sum 변수에 동시에 접근하기 때문에, 둘간에 동기화를 하지 않을 경우 sum 변수의 값이 잘 못되는 현상을 말한다.


</div>
</details>

<details>
<summary>임계구역 해결 방법엔 어떤 것들이 있나요 ? </summary>
<div markdown="1">

1. 세마포어
2. 뮤텍스
3. 모니터

</div>
</details>
<details>
<summary>피터슨 알고리즘에 대해서 설명해보세요 </summary>
<div markdown="1">

</div>
</details>

<details>
<summary>데커 알고리즘에 대해서 설명해보세요 </summary>
<div markdown="1">

</div>
</details>

<details>
<summary>데드락이란 무엇인가요 ?</summary>
<div markdown="1">



</div>
</details>

<details>
<summary>데드락을 해결하는 방법은 무엇이 있나요?</summary>
<div markdown="1">

</div>
</details>

<br/>

<details>
<summary>경쟁상태란 무엇인가요 ?</summary>

- 여러 프로세스가 공유 자원에 동시에 접근하여, 프로세스들의 공유 자원 접근 순서에 따라 실행 결과가 달라지는 현상이다.

</div>
</details>

<br/>


<details>
<summary> 🚧 바쁜 대기(busy waiting) 과 block-and-wakeup 방식의 차이점이 무엇인가? </summary>
<div markdown="1">

- 공유 자원을 사용하기 위해 프로세스가 대기할 때, CPU자원을 소모하는지 아닌지에 따라서 차이가 있다.

<br/>

</div>
</details>

<br/>


<details>
<summary> 🚧 바쁜 대기(busy waiting) 와 block-and-wakeup 방식은 언제 사용하는가?  
 </summary>
<div markdown="1">

- 바쁜 대기로 대기하는 시간이 짧고, block-and-wakeup으로 인해 프로세스의 상태 전환 비용이 더 비쌀 경우에 바쁜 대기를 사용한다. 
- 그 반대의 경우에 block-and-wakeup을 사용한다.

</div>
</details>

<br/>

<details>
<summary> 🚧 세마포어를 잘못 사용할 때 발생할 수 있는 문제점
 </summary>
<div markdown="1"> 

</div>
</details>

<br/>


<details>
<summary>🚧뮤텍스, 세마포어, 모니터가 언어에서 어떻게 사용되나요 ?</summary>
<div markdown="1">

- Kotlin
- Swift

</div>
</details>

