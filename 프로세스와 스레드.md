# 1️⃣ 프로세스와 스레드

<details>
<summary>프로세스란?</summary>
<div markdown="1">

프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다. 
운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 
구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

</div>
</details>

<br/>

<details>
<summary>스레드란?</summary>
<div markdown="1">

- 프로세스 내에 존재하는 실행단위
- 테스크라고도 불림

</div>
</details>

<br/>

<details>
<summary>프로세스 주소 공간 구성</summary>
<div markdown="1">

Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)

Data : 전역변수, 정적변수, 배열 등

초기화 된 데이터는 data 영역에 저장  
초기화 되지 않은 데이터는 bss 영역에 저장  
Heap : 동적 할당 시 사용 (new(), malloc() 등)
Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)

</div>
</details>

<br/>

<details>
<summary>주소 공간을 이렇게 나누는 이유?</summary>
<div markdown="1"> 

공통된 부분은 최대한 공유하여 컴퓨터 시스템 리소스(메모리) 절약하기 위해
동일한 프로그램이라면 코드와 데이터는 메모리에 한번만 할당되어 존재해도 충분하다, 이것을 공유하여 사용함으로써 시스템 리소스를 절약하기 위함이다.

</div>
</details>

<br/>

<details>
<summary>스레드란?</summary>
<div markdown="1">

- 프로세스 내에 존재하는 실행단위
- 테스크라고도 불림

</div>
</details>

<br/>

<details>
<summary>프로세스란 🆚 스레드</summary>
<div markdown="1">
가장 큰 차이점: 프로세스 주소공간 공유여부‼️
프로세스는 독립적인 프로세스 주소 공간을 갖고, 동일한 프로세스 내에 존재하는 스레드들은 프로세스의 주소 공간을 공유한다.

스레드가 다른 스레드와 공유하는 것
- 코드 영역
- 데이터 영역
- 운영체제 자원

단, 프로세스의 주소 공간 중에서도 독립적으로 갖는 것이 존재
- 스택 영역
- CPU register set (Program Counter 포함)

</div>
</details>

<br/>

<details>
<summary>스레드를 사용하는 이유</summary>
<div markdown="1"> 

= 멀티 스레드 사용 이유와 동일하다.  
간단 요약: 멀티태스킹의 낭비 요소를 제거하기 위해 사용한다. 

</div>
</details>

<br/>

<details>
<summary>스택을 스레드마다 독립적으로 할당하는 이유</summary>
<div markdown="1">

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

</div>
</details>

<br/>

<details>
<summary>PC Register 를 스레드마다 독립적으로 할당하는 이유</summary>
<div markdown="1">

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다. 스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.

</div>
</details>

<br/>

<details>
<summary>프로세스 제어 블록 (PCB)</summary>
<div markdown="1">

- 프로세스의 작업지시서이다
- 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조, 운영체제 영역에 만들어짐
- 프로세스가 종료되면 프로세스와 프로세스 제어블록 제거
- 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어블록을 받았다는 의미이다

</div>
</details>

<br/>

<details>
<summary>프로세스 제어블록(PCB)의 구성</summary>
<div markdown="1">

- 프로세스 구분자 (PID)
  - 여러 프로세스를 구분하는 아이디
- 메모리 관련 정보
  - 프로세스가 올라간(실행중인) 메모리의 위치 정보
    - 경계 레지스터
    - 한계 레지스터
- 각종 중간값 (상태 저장값)
  - 시분할 시스템과 연관지어 생각할 것 → 상태 저장이 필요함
  - 프로그램 카운터 레지스터
    - 다음에 작업해야할 코드의 위치

</div>
</details>

<br/>

<details>
<summary>프로그램 🆚 프로세스 </summary>
<div markdown="1">

- 프로그램은 저장장치에 저장된 정적인 상태
- 프로세스는 실행을 위해 메모리에 올려온 동적인 상태

</div>
</details>

<br/>

<details>
<summary>"프로세스가 실행된다"의 의미</summary>
<div markdown="1">

1. 운영체제가 저장장치에 저장된 프로그램을 메모리의 적당한 위치로 가져온다
2. 프로세스 제어블록을 생성한다.

</div>
</details>

<br/>

<details>
<summary>"운영체제도 프로세스이다 !</summary>
<div markdown="1">

- 운영체제도 프로그램이고, 프로세스이다.
- 컴퓨터 입장에선 유저 프로세스와 커널 프로세스로 구분된다.
- 일반 사용자 (일반 프로그램) → 유저 프로세스 실행
  - **운영체제**가 일반 프로그램을 메모리에 올림
  - 일반 사용자의 유저 프로세스 (user process)
- 운영체제 (운영체제 프로그램)
  - **부트스트랩**이 운영체제 프로그램을 메모리에 올림 → 커널 프로세스 실행
  - 운영체제의 커널 프로세스 (kernel process)

</div>
</details>

<br/>

<details>
<summary>🚧 유저 프로세스와 커널 프로세스의 차이</summary>
<div markdown="1">

- 일반 사용자 (일반 프로그램) → 유저 프로세스 실행
  - **운영체제**가 일반 프로그램을 메모리에 올림
  - 일반 사용자의 유저 프로세스 (user process)
  - 유저 메모리 영역만 접근 가능
  - 시스템에 제한된 접근만 가능
- 운영체제 (운영체제 프로그램)
  - **부트스트랩**이 운영체제 프로그램을 메모리에 올림 → 커널 프로세스 실행
  - 운영체제의 커널 프로세스 (kernel process)
  - 모든 메모리 영역 (유저 메모리 영역 + 커널 메모리 영역)
  - 모든 명령어 실행 가능

</div>
</details>

<br/>

<details>
<summary> 부트스트랩이란</summary>
<div markdown="1">

운영체제를 실행할 때 필요한 초기화 작업을 수행하고, 최종적으로 운영체제를 메모리에 로딩하여 실행시키는 프로그램

- 출처
https://www.techopedia.com/definition/3328/bootstrap#:~:text=A%20bootstrap%20is%20the%20program,program%20such%20as%20the%20OS

</div>
</details>

<br/>

<details>
<summary>일괄 작업 시스템의 프로세스 상태</summary>
<div markdown="1">

- 생성 상태 → 실행 상태 → 완료 상태

</div>
</details>

<br/>

<details>
<summary>시분할 시스템의 프로세스 상태, 4가지</summary>
<div markdown="1">

- 생성 상태
  - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
  - 운체가 프로세스 제어블록을 생성하는 상태 (생성 상태가 끝나면 PCB 존재)
- 준비 상태
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- 실행 상태
  - 준비 상태인 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태
    - CPU를 얻는다 (디스패치)
  - 주어진 시간동안 작업이 완료되지 못했다면, 준비 상태로 돌아가 차례를 기다림 (타임아웃, 클록으로 부터 인터럽트를 받고 타임아웃됨)
- 완료 상태
  - 실행 상태의 프로세스가 주어진 시간(타임 슬라이스, 타임 퀀텀)동안 작업을 마쳐, 프로세스 제어블록이 사라진 상태 (완료 상태가 시작되었다면 PCB 제거된 상태)

</div>
</details>

<br/>

<details>
<summary> 현대 운영체제에서 프로세스의 5가지 상태 (활성 상태)</summary>
<div markdown="1">

- 현대의 복잡성을 대비하기 위해 **프로세스의 4가지 상태**에서 발전함
- 생성 상태
- 준비 상태
- 실행 상태
- **대기 상태**
- 완료 상태

</div>
</details>

<br/>

<details>
<summary>🚧프로세스의 힙에는 어떤 내용이 저장되는가 ?</summary>
<div markdown="1">
</div>
</details>

<br/>

<details>
<summary>🚧 프로세스 실행중에 힙이 어떻게, 언제 할당 되는가?  </summary>
<div markdown="1">


</div>
</details>

<br/>

<details>
<summary>🚧 PPID, CPID가 필요한 이유</summary>
<div markdown="1">
</div>
</details>

<br/>

## 스터디 진행 내용
1. TCB, TLS
   - https://en.wikipedia.org/wiki/Thread_control_block
   - http://egloos.zum.com/sweeper/v/1985738
2. 유저 레벨 스레드 <-> 커널 레벨 스레드 
   - 운영체제가 관리하는 스레드도 알아두면 좋다!
   - https://www.crocus.co.kr/1255
3. 프로세스의 실행 로직 (레지스터 셋 change 등등)
4. fork() <-> exec() 차이점
5. 유저 메모리 영역, 커널 메모리 영역 나누는 이유  
https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=sheep_horse&logNo=221271778167


<details>
<summary>스택 영역의 주소 공간만 높은 주소 -> 낮은 주소로 자라나는 이유</summary>
<div markdown="1">

스택영역은 다른 영역들과 달리 높은 주소에서 낮은 주소로 자라나는 형태를 가진다.

이러한 이유는 스택영역이 운영체제의 핵심인 커널영역을 침범할 수 없기 때문인데 이렇게 된다면 스택영역이 엄청나게 커지더라도 커널영역을 침범하지 않게 된다.

다른 이유는 스택영역과(높은 주소에서 낮은 주소로) 힙영역(낮은 주소에서 높은 주소로)이 공간을 공유하면서 사용하게 되면 공간을 효율적으로 사용할 수 있기 때문이다.(위 그림을 보면 쉽게 이해할 수 있을 것이다.)

스택영역은 후입선출, LIFO(Last In First Out)구조를 가지는데 말 그대로 가장 마지막에 들어간 것이 가장 먼저 나오는 것을 의미한다.

예시를 들면 신문을 쌓아놓고 판매하는 곳이 있다면 구입해 가는 사람들은 맨 위에 있는 신문부터 가져가는 것과 같다.

스택영역은 PUSH와 POP 명령을 통해 작동하는데 PUSH란 스택영역에 데이터를 집어넣을 때 사용되며, POP은 스택영역에서 데이터를 꺼낼 때 사용된다.
출처: https://hdacker.tistory.com/6
</div>
</details>

<details>
<summary> 커널 메모리 영역, 유저 메모리 영역 구분짓는 기준이 무엇인가? 언제 결정되는가? </summary>
<div markdown="1">

http://egloos.zum.com/rousalome/v/9997899

</div>
</details>

6. 커널 모드와 유저 모드의 차이
7. 언제 대기 상태(block 상태)로 전환되는가? 언제 대기 상태(block 상태)에서 돌아오는가?
8. 대기 상태로 전환되는 과정, 대기 상태에서 회복되는 과정

