# 1️⃣ 프로세스와 스레드

<details>
<summary>프로세스란?</summary>
<div markdown="1">

프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다. 
운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 
구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

</div>
</details>

<details>
<summary>스레드란?</summary>
<div markdown="1">

- 프로세스 내에 존재하는 실행단위
- 테스크라고도 불림

</div>
</details>

<details>
<summary>프로세스란 주소 공간 구성</summary>
<div markdown="1">

Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)

Data : 전역변수, 정적변수, 배열 등

초기화 된 데이터는 data 영역에 저장
초기화 되지 않은 데이터는 bss 영역에 저장
Heap : 동적 할당 시 사용 (new(), malloc() 등)

Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)>

</div>
</details>
<details>
<summary>🚧 주소 공간을 이렇게 나누는 이유?</summary>
<div markdown="1"> 

공통된 부분은 최대한 공유하여 컴퓨터 시스템 리소스(메모리) 절약하기 위해
동일한 프로그램이라면 코드와 데이터는 메모리에 한번만 할당되어 존재해도 충분하다, 이것을 공유하여 사용함으로써 시스템 리소스를 절약하기 위함이다.

</div>
</details>

<details>
<summary>스레드란?</summary>
<div markdown="1">

- 프로세스 내에 존재하는 실행단위
- 테스크라고도 불림

</div>
</details>

<details>
<summary>프로세스란 🆚 스레드</summary>
<div markdown="1">
가장 큰 차이점: 프로세스 주소공간 공유여부‼️
프로세스는 독립적인 프로세스 주소 공간을 갖고, 동일한 프로세스 내에 존재하는 스레드들은 프로세스의 주소 공간을 공유한다.

스레드가 다른 스레드와 공유하는 것
- 코드 영역
- 데이터 영역
- 운영체제 자원

단, 프로세스의 주소 공간 중에서도 독립적으로 갖는 것이 존재
- 스택 영역
- CPU register set (Program Counter 포함)

</div>
</details>

<details>
<summary>🚧 스레드를 사용하는 이유</summary>
<div markdown="1"> 

공통된 부분은 최대한 공유하여 컴퓨터 시스템 리소스(메모리) 절약하기 위해
동일한 프로그램이라면 코드와 데이터는 메모리에 한번만 할당되어 존재해도 충분하다, 이것을 공유하여 사용함으로써 시스템 리소스를 절약하기 위함이다.

</div>
</details>


<details>
<summary>스택을 스레드마다 독립적으로 할당하는 이유</summary>
<div markdown="1">

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

</div>
</details>

<details>
<summary>PC Register 를 스레드마다 독립적으로 할당하는 이유</summary>
<div markdown="1">

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다. 스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.

</div>
</details>

<details>
<summary>프로세스 제어 블록 (PCB)</summary>
<div markdown="1">

- 프로세스의 작업지시서이다
- 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조, 운영체제 영역에 만들어짐
- 프로세스가 종료되면 프로세스와 프로세스 제어블록 제거
- 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어블록을 받았다는 의미이다

</div>
</details>

<details>
<summary>프로세스 제어블록(PCB)의 구성</summary>
<div markdown="1">

- 프로세스 구분자 (PID)
  - 여러 프로세스를 구분하는 아이디
- 메모리 관련 정보
  - 프로세스가 올라간(실행중인) 메모리의 위치 정보
    - 경계 레지스터
    - 한계 레지스터
- 각종 중간값 (상태 저장값)
  - 시분할 시스템과 연관지어 생각할 것 → 상태 저장이 필요함
  - 프로그램 카운터 레지스터
    - 다음에 작업해야할 코드의 위치

</div>
</details>

<details>
<summary>프로그램 🆚 프로세스 </summary>
<div markdown="1">

- 프로그램은 저장장치에 저장된 정적인 상태
- 프로세스는 실행을 위해 메모리에 올려온 동적인 상태

</div>
</details>

- 프로세스 = 프로그램 + 프로세스 제어블록❓
  - PCB는 운영체제 영역에 존재하는 것인데 프로세스의 구성요소라고 볼 수 있는지 궁금해요‼️

<details>
<summary>"프로세스가 실행된다"의 의미</summary>
<div markdown="1">

1. 운영체제가 저장장치에 저장된 프로그램을 메모리의 적당한 위치로 가져온다
2. 프로세스 제어블록을 생성한다.

</div>
</details>

<details>
<summary>"운영체제도 프로세스이다 !</summary>
<div markdown="1">

- 운영체제도 프로그램이고, 프로세스이다.
- 컴퓨터 입장에선 유저 프로세스와 커널 프로세스로 구분된다.
- 일반 사용자 (일반 프로그램) → 유저 프로세스 실행
  - **운영체제**가 일반 프로그램을 메모리에 올림
  - 일반 사용자의 유저 프로세스 (user process)
- 운영체제 (운영체제 프로그램)
  - **부트스트랩**이 운영체제 프로그램을 메모리에 올림 → 커널 프로세스 실행
  - 운영체제의 커널 프로세스 (kernel process)

</div>
</details>


<details>
<summary>🚧 유저 프로세스와 커널 프로세스의 차이</summary>
<div markdown="1">

- 일반 사용자 (일반 프로그램) → 유저 프로세스 실행
  - **운영체제**가 일반 프로그램을 메모리에 올림
  - 일반 사용자의 유저 프로세스 (user process)
- 운영체제 (운영체제 프로그램)
  - **부트스트랩**이 운영체제 프로그램을 메모리에 올림 → 커널 프로세스 실행
  - 운영체제의 커널 프로세스 (kernel process)

</div>
</details>


🚧 부트스트랩이란

<details>
<summary>일괄 작업 시스템의 프로세스 상태</summary>
<div markdown="1">

- 생성 상태 → 실행 상태 → 완료 상태

</div>
</details>

<details>
<summary>시분할 시스템의 프로세스 상태, 4가지</summary>
<div markdown="1">

- 생성 상태
  - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
  - 운체가 프로세스 제어블록을 생성하는 상태 (생성 상태가 끝나면 PCB 존재)
- 준비 상태
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- 실행 상태
  - 준비 상태인 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태
    - CPU를 얻는다 (디스패치)
  - 주어진 시간동안 작업이 완료되지 못했다면, 준비 상태로 돌아가 차례를 기다림 (타임아웃, 클록으로 부터 인터럽트를 받고 타임아웃됨)
- 완료 상태
  - 실행 상태의 프로세스가 주어진 시간(타임 슬라이스, 타임 퀀텀)동안 작업을 마쳐, 프로세스 제어블록이 사라진 상태 (완료 상태가 시작되었다면 PCB 제거된 상태)

</div>
</details>

<details>
<summary>🚧 현대 운영체제에서 프로세스의 5가지 상태 (활성 상태)</summary>
<div markdown="1">

- 현대의 복잡성을 대비하기 위해 **프로세스의 4가지 상태**에서 발전함
- 생성 상태
- 준비 상태
- 실행 상태
- **대기 상태**
- 완료 상태

</div>
</details>


<details>
<summary>🚧 프로세스의 힙에는 어떤 내용이 저장되는가 ?</summary>
<div markdown="1">
</div>
</details>


<details>
<summary>🚧 프로세스 실행중에 힙이 어떻게, 언제 할당 되는가?  </summary>
<div markdown="1">
</div>
</details>



<details>
<summary>🚧 PPID, CPID가 필요한 이유</summary>
<div markdown="1">
</div>
</details>


<details>
<summary>🚧 스레드를 사용하는 이유</summary>
<div markdown="1">
  - 멀티태스킹의 낭비 요소를 제거하기 위해 사용한다. 
</div>
</details>


